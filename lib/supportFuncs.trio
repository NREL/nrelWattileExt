name:toWattileModels
doc:
  Read all `wattileModel` records associated with 'points'.
func
src:
  (points) => do
    // Read models
    models: points
      .toRecList
      .findAll(p => p.has("wattileModelRef"))
      .map(p => readById(p->wattileModelRef))
    
    // Ensure unique
    models.toGrid.unique("id")
  end
---
name:toWattilePoints
doc:
  Read all `wattilePoint` points associated with 'wattileModels' via `wattileModelRef`.
func
src:
  (wattileModels) => do
    wattileModels
      .toRecList
      .toGrid
      .flatMap() model => do
        readAll(point and wattilePoint and wattileModelRef==model.toRecId).toRecList
      end
  end
---
name:wattileExportTrainingData
doc:
  For the specified 'predictors', 'targets', and time 'span', export historical data to directory 'dir' for training Wattile models. 'predictors' and 'targets' are any inputs supported by `toRecList()`; 'span' is any input supported by `toSpan()`. The exported data are consistent with the [training data input format]`https://github.com/NREL/Wattile/blob/main/docs/Data_configs.md` required by Wattile.
  
  Details
  -------
  
  Writes the following files within 'dir':
  
  - '<<Name>> Predictors <<Date Range>>.csv': Time series file(s) containing predictor (input) data in CSV format
  - '<<Name>> Targets <<Date Range>>.csv': Time series file(s) containing target (output) data in CSV format
  - '<<Name>> Config.json': Data set configuration metadata in JSON format
  
  In the filenames, '<<Name>>' is the data set name (which defaults to the name of 'dir'; see *Options*) and '<<Date Range>>' is the date range spanned by each file (with format dependent on the export options selected).
  
  Each CSV file contains a 'Timestamp' column followed by one or more numeric value columns corresponding to either the predictor or the target points. Timestamps are exported in [ISO 8601]`https://en.wikipedia.org/wiki/ISO_8601` standard format, including time zone offset and time zone name. Only numeric data are supported.
  
  The JSON configuration file consists of a single top-level dictionary containing five nested dictionaries:
  
  - 'dates': The data set 'start' and 'end' dates (timestamps)
  - 'predictors': A list of predictor variables, including the following metadata for each, as available:
    - 'id': Unique identifier
    - 'dis': Display name; populated via `dis()`
    - 'column': Column name in CSV file(s)
    - 'unit': Unit
    - 'maxVal': Maximum valid value
    - 'minVal': Minimum valid value
    - 'defVal': Default value; substituted automatically for out-of-range data
  - 'targets': A list of target variables, including at minimum
    the 'column' field and following the same conventions as 'predictors'
  - 'files': Provides a list of all CSV files in the data set, each as an dictionary
    with the following metadata:
    - 'filename': Name of the associated CSV file
    - 'contentType': Either '"predictors"' or '"targets"'
    - 'start': Start of the time range spanned by the file
    - 'end': End of the time range spanned by the file
  - 'export_options': The 'opts' arguments used for the export (provided for repeatability)
  
  The JSON configuration file uses Haystack [Json]`docHaystack::Json` encoding (Version 3 by default; see *Options*). Unicode characters are not escaped.
  
  Options
  -------
  
  Export behavior can be modified by control options passed via 'opts':
  
  - 'appendUnits': [Boolean]`sys::Bool`; if 'true' then units will be appended to column names (Default = false)
  - 'clean': [Boolean]`sys::Bool`; see `wattileReadHis()` (Default = false)
  - 'batch'; [Integer]`haystack::Number`; see `wattileReadHis()` (Default = none)
  - 'defVal': `haystack::Number` or `haystack::NA`; see `wattileReadHis()` (Default = none)
  - 'interpolate': [Boolean]`sys::Bool`; see `wattileReadHis()` (Default = false)
  - 'interval': `haystack::Number`; see `wattileReadHis()` (Default = none)
  - 'jsonVersion': `sys::Str`; either 'v3' or 'v4'; see [Json]`docHaystack::Json` (Default = 'v3')
  - 'name': `sys::Str`; data set name to use in output files (Default = name of 'dir')
  - 'preview': [Boolean]`sys::Bool`; if 'true' then return the data set configuration JSON without writing any files (Default = false)
  - 'removeNA': [Boolean]`sys::Bool`; see `wattileReadHis()` (Default = false)
  - 'rollup': [Boolean]`sys::Bool`; see `wattileReadHis()` (Default = false)
  - 'splitBy': `sys::Str`; One of "day", "week", "month", or "year" indicating the interval at which to split the data files (Default = no splitting)
  - 'timeout': `haystack::Number`; see `wattileReadHis()` (Default = none)
  - 'warn': [Boolean]`sys::Bool`; see `wattileReadHis()` (Default = true)
  
  Boolean options may be also be passed as [markers]`haystack::Marker`, with 'x' equivalent to 'x:true' and '-x' equivalent to 'x:false'.
  
  Pre-Processing
  --------------
  
  Options 'clean', 'defVal', 'interpolate', 'interval', and 'rollup' control data pre-processing prior to export. See `wattileReadHis` for each option's effect.
  
  Note: interpolation is performed for each exported CSV file independently, therefore, the set of timestamps in target and predictor CSV file for the same date range are not guaranteed to be the same.
  
  Tips
  ----
  
  - If you are trying to read history from remote projects via Arcbeam and keep seeing an error that XQuery did not return the correct number of points, experiment with increasing 'timeout' and/or decreasing 'batch'. See `wattileReadHis` for details.
func
overridable
src:
  (predictors, targets, span, dir, opts:{}) => do
    // Argument parsing
    predictors = predictors.toRecList.sort((a, b) => a.dis <=> b.dis)
    targets = targets.toRecList.sort((a, b) => a.dis <=> b.dis)
    span = span.toSpan
    if (dir.isStr) dir = parseUri(dir)
  
    // Default options
    opts = {
      appendUnits: false,
      clean:       false,
      interpolate: false,
      jsonVersion: "v3",
      preview:     false,
      removeNA:    false,
      rollup:      false,
      warn:        true
    }.merge(opts)
  
    // T/F options
    opts = opts.set("appendUnits", opts.has("appendUnits") and opts["appendUnits"] != false)
    opts = opts.set("clean",       opts.has("clean")       and opts["clean"]       != false)
    opts = opts.set("interpolate", opts.has("interpolate") and opts["interpolate"] != false)
    opts = opts.set("preview",     opts.has("preview")     and opts["preview"]     != false)
    opts = opts.set("removeNA",    opts.has("removeNA")    and opts["removeNA"]    != false)
    opts = opts.set("rollup",      opts.has("rollup")      and opts["rollup"]      != false)
    opts = opts.set("warn",        opts.has("warn")        and opts["warn"]        != false)
  
    // Verify directory
    if (not dir.uriIsDir) throw "'dir' `" + dir.toStr + "` is not a directory."
  
    // Default name = name of directory
    if (opts.missing("name")) opts = opts.set("name", dir.uriName)
  
    // Verify JSON version option
    if (not opts["jsonVersion"].in(["v3", "v4"])) do
      throw "'jsonVersion' option must be either \"v3\" or \"v4\"."
    end
  
    // Time splitting
    if (opts["splitBy"] == null) do
      spans: [span]
      spanLabels: null
    else if (opts->splitBy == "day") do
      spans: span.toDayList(true)
      spanLabels: spans.map(s => s.start.format("YYYY-MM-DD"))
    else if (opts->splitBy == "week") do
      spans: span.toWeekList(true)
      spanLabels: spans.map(s => s.start.format("'Week of 'YYYY-MM-DD"))
    else if (opts->splitBy == "month") do
      spans: span.toMonthList(true)
      spanLabels: spans.map(s => s.start.format("YYYY-MM"))
    else if (opts->splitBy == "year") do
      spans: span.toYearList(true)
      spanLabels: spans.map(s => s.start.format("YYYY"))
    else do
      throw "'splitBy' option must be one of: \"day\", \"week\", \"month\", \"year\"."
    end
  
    // Standardize column labels for output
    setColumnLabel: point => do
      // Column description
      dis: point.dis
  
      // Append units?
      if (opts->appendUnits and point.has("unit")) do
        dis = dis + " (" + point->unit + ")"
      end
  
      // Store 'dis' = column label on export
      point.merge({dis:dis, column:dis, -disMacro})
    end
    targets = targets.map(setColumnLabel)
    predictors = predictors.map(setColumnLabel)
  
    // Internal function to remove units
    hisRemoveUnits: (hisGrid) => do
      hisGrid.hisMap() (v, t) => if (v.isNumber) v.as("") else v
    end
  
    // Options to pass through to wattileReadHis()
    readOptNames: ["clean", "batch", "defVal", "interpolate", "interval", "removeNA", "rollup", "timeout", "warn"]
    readOpts: opts.findAll((val, key) => key.in(readOptNames))
  
    // Internal function to read, process, and export history for specific time range
    hisExportInternal: (points, spanLocal, file) => do
      // Read and pre-process data
      data: wattileReadHis(points, spanLocal, readOpts)
  
      // Remove units
      data = data.hisRemoveUnits
  
      // Timestamp column label
      data = data.addColMeta("ts", {dis:"Timestamp"})
  
      // Write to file
      if (not opts->preview) data.ioWriteCsv(file)
  
      // Return file metadata
      return {
        filename: file.uriName,
        start:    spanLocal.start,
        end:      spanLocal.end
      }
    end
  
    // Export targets
    targetFiles: spans.map() (s, i) => do
      // Output filename
      suffix: if (spanLabels != null) (" " + spanLabels[i]) else ""
      f: opts->name + " " + "Targets" + suffix + ".csv"
  
      // Execute export and return file info
      hisExportInternal(targets, s, dir + f).merge({contentType:"targets"})
    end
  
    // Export predictors
    predictorFiles: spans.map() (s, i) => do
      // Output filename
      suffix: if (spanLabels != null) (" " + spanLabels[i]) else ""
      f: opts->name + " " + "Predictors" + suffix + ".csv"
  
      // Execute export and return file info
      hisExportInternal(predictors, s, dir + f).merge({contentType:"predictors"})
    end
  
    // Formatting function for point records
    formatRecForJSON: rec => removeNull({
        id:     rec->id,
        dis:    rec->dis,
        column: rec->dis,
        unit:   rec["unit"],
        minVal: rec["minVal"],
        maxVal: rec["maxVal"],
        defVal: rec["defVal"]
      })
  
    // Organize predictor and target lists
    pointColOrder: ["id", "dis", "column", "unit", "minVal", "maxVal", "defVal"]
    predictors = predictors.map(formatRecForJSON).toGrid.reorderCols(pointColOrder)
    targets = targets.map(formatRecForJSON).toGrid.reorderCols(pointColOrder)
  
    // Organize file list
    fileColOrder: ["filename", "contentType", "start", "end"]
    files: targetFiles.addAll(predictorFiles).toGrid.reorderCols(fileColOrder)
  
    // Create structure for JSON conversion
    configuration: {
      dates:          {start:span.start, end:span.end},
      predictors:     predictors.toRecList,
      targets:        targets.toRecList,
      files:          files.toRecList,
      export_options: opts.remove("preview")
    }
  
    // Write JSON
    if (not opts->preview) do
      jsonOpts: {noEscapeUnicode}.set(opts->jsonVersion, marker())
      configuration.ioWriteJson(dir + (opts->name + " " + "Config.json"), jsonOpts)
    end
  
    // Return
    configuration
  end
---
name:wattileImportModels
doc:
  Imports proxy records for Wattile model(s) located in 'dirs' and optionally commits them to the database. 'dirs' may be a single uri, a list of uris, a list of anything that can be parsed to a uri, or a grid with a 'uri' column.
  
  Each imported model is a dict with tags:
  
  - `wattileModel`
  - `wattilePredictors`: `haystack::Grid` of predictor metadata (see [documentation]`ext-nrelWattile::doc#proxy`)
  - `wattileTargetRef`: Optional `haystack::Ref` to the prediction target (if available from 'predictors_target_config.json'; see [documentation]`ext-nrelWattile::doc#proxy`)
  - `wattileVersion`: Optional Wattile version string (if available from 'metadata.json'; see [documentation]`ext-nrelWattile::doc#proxy`)
  - `uri`: Path to the model directory
  - `unit`: Optional unit for the prediction output
  
  Does not populate optional tags `dis`, `tz`, or `wattileReadOpts` (as this information is not currently included with Wattile models). Returns a list of model records.
  
  Options
  -------
  
  Import behavior can be modified by control options passed via 'opts':
  
  - 'checked': [Boolean]`sys::Bool`; throw an error for invalid models (Default = 'true')
  - 'commit': [Boolean]`sys::Bool`; if 'true' commits the model records to the database (Default = 'false')
  - 'conflict': Action on conflicts; one of "skip", "overwrite", "duplicate", or "error" (Default = "error")
  - 'warn': [Boolean]`sys::Bool`; if 'true' log warnings; if 'false' suppress them (Default = true)
  
  Boolean options may also be passed as [markers]`haystack::Marker`, with 'x' equivalent to 'x:true' and '-x' equivalent to 'x:false'.
  
  Conflicts
  ---------
  
  Conflicts with existing `wattileModel` records (matched by 'uri') are handled based on the 'conflict' option:
  
    - skip: Skip import
    - overwrite: Merge imported metadata onto existing record, overwriting it
    - duplicate: Create a new `wattileModel` record with duplicate `uri`
    - error: Throw error
  
  Model Validation
  ----------------
  
  This function performs some basic validation on imported models, including checking directory integrity and verifying the existence of the model's predictor and target points within the SkySpark cluster. Behavior on encountering an invalid model depends on the 'checked' option:
  
  - If 'checked' is 'true', throws an error when an invalid model is encountered
  - If 'checked' is 'false', skips invalid models...
    - If 'warn' is 'true', with a warning
    - If 'warn' is 'false', silently
func
overridable
src:
  (dirs, opts:{}) => do
    // Default options
    opts = {checked:true, warn:true, conflict:"error"}.merge(opts)
  
    // T/F options
    opts = opts.set("checked", opts.has("checked") and opts["checked"] != false)
    opts = opts.set("commit",  opts.has("commit")  and opts["commit"]  != false)
    opts = opts.set("warn",    opts.has("warn")    and opts["warn"]    != false)
  
    // Action on conflict
    opts = opts.set("conflict", opts->conflict.lower)
    if (not opts->conflict.in(["skip", "overwrite", "duplicate", "error"])) do
      throw "'conflict' option must be one of: \"skip\", \"overwrite\", \"duplicate\""
    end
  
    // Coerce dirs to Uri list
    if (dirs.isGrid) do
      dirs = dirs.colToList("uri")
    else do
      dirs = dirs.toList
    end
  
    // Map dirs to records
    models: dirs.map() dir => do
      // Check directory uri
      if (not dir.isUri) do
        dir = dir.parseUri(opts->checked)
      end
  
      // Verify directory integrity
      try do
        if (dir.isNull) throw "Model directory is null"
        if (ioInfo(dir).missing("dir")) throw "`" + dir.toStr + "` is not a directory"
        if (ioDir(dir).isEmpty) throw "Model directory `" + dir.toStr + "` is empty or does not exist"
        if (ioDir(dir).find(f => f->name=="predictors_target_config.json", false) == null) throw "Model directory `" + dir.toStr + "` is missing \"predictors_target_config.json\""
      catch (ex) do
        if (opts->checked) do
          throw (ex)
        else if (opts->warn) do
          logWarn({name:"nrelWattile", funcTrace:"wattileImportModels"}, "Import skipped for: " + dir.toStr, ex)
        end
        return null // Invalid model
      end
  
      // Model dict
      model: {wattileModel, uri:dir, dis:uriBasename(dir)}
  
      // Build up model dict with predictors and targets
      try do
        // Read config
        predictorConfig: ioReadJson(dir + "predictors_target_config.json", {v3}) // TO DO: Update to v4 encoding
  
        // Get predictors
        predictors: predictorConfig->predictors
          .map() p => do
            // Check for required tags
            if (p.missing("id")) throw "Predictor " + p.dis + " is missing 'id' key."
            if (p.missing("column")) throw "Predictor " + p.wattileRecDisWithId + " is missing 'column' key."
  
            // Default 'dis' to "description" key value, if present
            if (p.missing("dis") and p.has("description")) do
              p = p.set("dis", p->description)
            end
  
            // Resolve ID and return
            p.set("id", wattileResolveRef(p["id"]))
          end
  
        // Predictors grid
        predictors = predictors.toGrid.keepCols(["id", "dis", "column", "unit", "minVal", "maxVal", "defVal"])
  
        // Store to model
        model = model.set("wattilePredictors", predictors)
  
        // Get target
        if (predictorConfig.has("target")) do
          // Target ref
          if (predictorConfig->target.missing("id")) throw "Target " + predictorConfig->target.dis + " is missing 'id' key."
          target: wattileResolveRef(predictorConfig->target->id)
  
          // Store to model
          model = model.set("wattileTargetRef", target)
  
          // Target's original units
          if (predictorConfig->target.has("unit")) do
            // Store to model
            model = model.set("unit", predictorConfig->target->unit)
          end
        end
        
      catch (ex) do
        if (opts->checked) throw (ex)
        return null // Invalid model
      end
  
      // Read additional metadata, if available
      // TO DO: Require this metadata file in the future?
      try do
        modelMeta: ioReadJson(dir + "metadata.json")
        if (modelMeta.has("wattile_version")) do
          model = model.set("wattileVersion", modelMeta->wattile_version)
        end
      catch (ex) do
        // Ignore if file does not exist; warn otherwise
        if (not ex.dis.contains("sys::IOErr: File does not exist")) do
          logWarn(
            {name:"nrelWattile", funcTrace:"wattileImportModels"},
            "Error reading model metadata file: " + (dir + "metadata.json").toStr,
            ex
          )
        end
      end
      
      // Return
      model
    end
  
    // Resolve existing models
    models = models
      .map(
        m => do
          // Missing?
          if (m == null) return null
          
          // Existing?
          existingModel: read(wattileModel and uri==m->uri, false)
  
          // No existing model
          if (existingModel == null) return m
  
          // Handle existing model
          if (opts->conflict == "overwrite") return m.set("id", existingModel.toRecId)
          if (opts->conflict == "duplicate") return m
          if (opts->conflict == "skip") return null
  
          // "error" or any other case
          throw "'wattileModel' for uri `" + m->uri + "` already exists."
        end
      )
      .findAll(m => m != null)
  
    // Commit?
    if (opts->commit) do
      diffs: models.map() m => if (m.has("id")) do
        diff(m.toRecId.readById, m.remove("id"))
      else do
        diff(null, m, {add})
      end
      models = diffs.commit
    end
  
    // Return models
    return models
  end
---
name:wattileReadHis
doc:
  For the specified 'points' and time 'span', read and pre-process historical data for use with a Wattile model. 'points' is any input supported by `toRecList()`; 'span' is any input supported by `toSpan()`. Returns a history grid.
  
  Options
  -------
  
  Data pre-processing is controlled by the following options, passed via 'opts':
  
  - 'clean': [Boolean]`sys::Bool`; if 'true' then data will be range-cleaned prior to export by removing values outside the range defined by each point's `minVal` and `maxVal` tags (Default = false)
  - 'batch': [Integer]`haystack::Number`; optional batch size for XQuery; see below (Default = none)
  - 'defVal': `haystack::Number` or `haystack::NA`; governs range cleaning behavior; see below (Default = none)
  - 'interpolate': [Boolean]`sys::Bool`; if 'true' then data will be interpolated (Default = false)
  - 'interval': `haystack::Number`; optional interval at which to interpolate and/or roll up the data (Default = none)
  - 'removeNA': [Boolean]`sys::Bool`; if 'true' then NA values will be removed (Default = false)
  - 'rollup': [Boolean]`sys::Bool`; if 'true' then a history rollup will be applied (Default = false)
  - 'timeout': `haystack::Number`; optional timeout for XQuery; see below (Default = none)
  - 'warn': [Boolean]`sys::Bool`; if 'true' log warnings; if 'false' suppress them (Default = true)
  
  Boolean options may be also be passed as [markers]`haystack::Marker`, with 'x' equivalent to 'x:true' and '-x' equivalent to 'x:false'. If 'rollup' is 'true', then 'interval' must also be specified.
  
  Range Cleaning
  --------------
  
  If 'clean' is 'true', values outside the range '[minVal, maxVal]', as defined by each point's `minVal` and `maxVal` tags, are removed from the data set. (Missing 'minVal' and 'maxVal' tags imply permissible minimum and maximum values of negative and positive infinity, respectively.)
  
  If the 'defVal' option is provided, values removed are replaced with 'defVal'; otherwise, they are replaced with Null. Optionally, 'defVal' may be passed as a tag on each point; 'defVal' point tags override the global option on a per-point basis.
  
  Range cleaning is performed prior to NA removal, interpolation, and/or rollup.
  
  NA Removal
  ----------
  
  If 'removeNA' is 'true', NA values will be removed from the data set, including any NA values generated from 'defVal' during range cleaning.
  
  NA removal is performed prior to interpolation and/or rollup.
  
  Interpolation
  -------------
  
  If 'interpolate' is 'true', the entire history grid is interpolated via `hisInterpolate()`, following SkySpark's normal interpolation rules. If the 'interval' option is also specified, then additional interpolation is performed *selectively* to ensure each interval of data contains at least one value for each input point. Interpolation is performed prior to rollup.
  
  Rollup
  ------
  
  If the 'rollup' option is provided, data are rolled up at the specified 'interval' using `hisRollupAuto()`.
  
  Handling Large History Reads
  ----------------------------
  
  Large or computationally-intensive history reads from remote projects can cause unexpected XQuery behavior, such as silent timeouts or keep-alive resets of the Arcbeam websocket. When this happens, you may see an error message like this:
  
    Expected X points; XQuery returned Y.
  
  Two options can help:
  
  - 'timeout' is passed through to `xq()`; increase it to allow each XQuery more time to complete
  - 'batch' sets the maximum number of points read per XQuery; decrease it to spread out the history reads over more XQueries
  
  Note: smaller 'batch' size reduces the chance of individual XQuery failures but increases both the total number of XQueries and the total function execution time.
func
overridable
src:
  (points, span, opts:{}) => do
    // Argument parsing
    points = points.toRecList
    span = span.toSpan
    
    // Check points
    if (points.isEmpty) do
      throw "'points' cannot be empty."
    end
  
    // Default options
    opts = {
      clean: false,
      interpolate: false,
      removeNA: false,
      rollup: false,
      warn: true
    }.merge(opts)
  
    // T/F options
    opts = opts.set("clean",       opts.has("clean")       and opts["clean"]       != false)
    opts = opts.set("interpolate", opts.has("interpolate") and opts["interpolate"] != false)
    opts = opts.set("removeNA",    opts.has("removeNA")    and opts["removeNA"]    != false)
    opts = opts.set("rollup",      opts.has("rollup")      and opts["rollup"]      != false)
    opts = opts.set("warn",        opts.has("warn")        and opts["warn"]        != false)
    
    // XQuery options
    if (opts.has("timeout")) do
      xqOpts: {timeout:opts->timeout}
    else do
      xqOpts: null
    end
    
    // XQuery read batches
    if (opts.has("batch")) do
      batchSize: floor(opts->batch)
      numBatch: ceil(points.size / batchSize)
      batches: (0..(numBatch-1)).map() b => do
        idxLow: b * batchSize
        idxHigh: idxLow + batchSize - 1
        getSafe(points, idxLow..idxHigh)
      end
    else do
      batches: [points]
    end
    
    // Internal function: Perform range cleaning (only if 'clean' option is set)
    if (opts->clean) do
      hisRangeCleanInternal: (hisGrid, point) => do
        // Get default value
        if (point.has("defVal")) do
          defVal: point->defVal
        else if (opts.has("defVal")) do
          defVal: opts->defVal
        else do
          defVal: null
        end
        
        // Warn if default value is NA and removeNA is set
        if (opts->warn and defVal == na() and opts->removeNA) do
          logWarn(
            {name:"nrelWattile", funcTrace:"wattileReadHis"},
            "Option 'removeNA' = true overrides a default value ('defVal' option) of NA; " +
            "NA data for " + point.wattileRecDisWithId + " will be replaced with Null."
          )
        end
  
        // Get range
        minVal: if (point.has("minVal")) point->minVal else negInf()
        maxVal: if (point.has("maxVal")) point->maxVal else posInf()
  
        // No default value: remove
        if (defVal == null) do
          hisGrid = hisGrid.hisFindAll((v, t) => v != na() and v >= minVal.to(v) and v <= maxVal.to(v))
  
        // Default value: replace
        else do
          hisGrid = hisGrid.hisMap() (v, t) => do
            if (v == na() or (v >= minVal.to(v) and v <= maxVal.to(v))) do
              return v
            else do
              return defVal
            end
          end
        end
  
        // Return
        return hisGrid
      end
    else do
      hisRangeCleanInternal: (hisGrid, point) => hisGrid
    end
  
    // Internal function: NA removal
    if (opts->removeNA) do
      hisRemoveNaInternal: (hisGrid) => hisGrid.hisFindAll(v => v != na())
    else do
      hisRemoveNaInternal: (hisGrid) => hisGrid
    end
  
    // Internal function: Interpolate intervals with no data (only if 'interpolate' option is set)
    if (opts->interpolate and opts.has("interval")) do
      hisInterpolateAtIntervalInternal: (hisGrid) => do
        // Find gaps (intervals with no data)
        gaps: hisGrid
          .hisRollup(count, opts->interval)
          .hisFindAll((val, ts) => val == 0)
          .keepCols(["ts"])
  
        // Interpolate gaps
        hisJoin([hisGrid, gaps]).hisInterpolate
      end
    else do
      hisInterpolateAtIntervalInternal: (hisGrid) => hisGrid
    end
  
    // Internal function: Final history interpolation (only if 'interpolate' option is set)
    if (opts->interpolate) do
      hisInterpolateInternal: (hisGrid) => hisGrid.hisInterpolate
    else do
      hisInterpolateInternal: (hisGrid) => hisGrid
    end
  
    // Internal function: Roll up history (only if 'interval' option is set)
    if (opts.has("interval")) do
      hisRollupInternal: (hisGrid) => do
        // Data type
        kind: hisGrid.col("v0").meta["kind"]
  
        // Numeric
        if (kind == "Number") do
          return hisGrid.hisRollupAuto(opts->interval)
  
        // Unsupported
        else do
          throw "Unsupported kind \"" + kind + "\" for point: " + hisGrid.col("v0").meta.wattileRecDisWithId
        end
      end
    else do
      hisRollupInternal: (hisGrid) => hisGrid
    end
  
    // Internal function: Convert units
    hisConvertUnits: (hisGrid, point) => do
      hisGrid.hisMap() (v, t) => if (v.isNumber) v.to(point["unit"]) else v
    end
  
    // Run XQuery in batches
    data: batches
      .map(batchPoints => xq(xqOpts)
        .xqDefine("readspan", span)
        .xqReadByIdsList(batchPoints.toRecIdList)
        .xqMap("p => {id:p->id, hisGrid:p.toRecId.hisRead(readspan, {-limit, hisKeepEmptyCols})}")
        .xqExecute  
      ).flatten
      
    // Verify all points found
    if (data.size < points.size) do
      throw "Expected " + points.size.toStr + " points; XQuery returned " + data.size + "."
    end
    
    // Process histories
    data = data.map() dict => do
      // Get corresponding point
      p: points.find(x => x->id == dict->id)
  
      // Extract history grid
      history: dict->hisGrid.addMeta({hisKeepEmptyCols})
  
      // Check for empty history
      if (opts->warn and history.hisClip.isEmpty) do
        logWarn(
          {name:"nrelWattile", funcTrace:"wattileReadHis"},
          "No history found for point " + p.wattileRecDisWithId +
          " and span " + format(span)
        )
      end
  
      // Preserve original 'dis', if applicable
      // Needed to enforce column names on CSV export
      if (p.has("dis")) do
        history = history.addColMeta("v0", {dis:p->dis, -disMacro})
      end
  
      // Range clean, rollup, enforce units, set column label
      history = history
        .hisRemoveNaInternal
        .hisRangeCleanInternal(p)
        .hisInterpolateAtIntervalInternal
        .hisRollupInternal
        .hisConvertUnits(p)
    end
  
    // Join, interpolate, clip to window, and return
    hisJoin(data)
      .hisInterpolateInternal
      .hisClip
  end
---
name:wattileResolveRec
doc:"Return the record Dict for 'ref'. If the record does not exist anywhere in the cluster, throw an error or return null based on the 'checked' flag."
func
overridable
src:
  (ref, checked:true) => do
    // Data type checking
    if (not ref.isRef) do
      throw "'ref' must be a Ref"
    end
    
    // Resolve
    try do
      // Try local database
      rec: ref.toRec
    catch (ex) do
      // Try cluster via XQuery
      refList: xq().xqReadByIdsList(ref.toList).xqExecute
  
      // Record not found
      if (refList.isEmpty) do
        if (checked) do
          throw "Ref @" + ref.toStr + " cannot be found anywhere in the cluster."
        else do
          rec: null
        end
      else if (refList.size > 1) do
        throw "Ref @" + ref.toStr + " did not resolve to a unique record!" // This shouldn't ever happen
      else do
        rec: refList.first
      end
    end
    
    // Return
    return rec
  end
---
name:wattileResolveRef
doc:
  Resolve 'refStr' into a valid `haystack::Ref`. If the record does not exist anywhere in the cluster, throw an error or return null based on the 'checked' flag.
  
  Handles any of the following:
  
  - With or without leading '@'
  - With or without trailing description
  - Absolute or relative
  - (Relative refs) with or without '"r:"' prefix
func
overridable
src:
  (refStr, checked:true) => do
    // Convert to string
    refStr = refStr.toStr
  
    // Trim 'dis' (if any)
    refStr = refStr.split(" ")[0]
  
    // Special cases: relative Refs
    if (refStr.startsWith("r:")) refStr = refStr[2..-1]
    if (refStr.startsWith("@r:")) refStr = refStr[3..-1]
  
    // Parse
    ref: parseRef(refStr)
  
    // Resolve via wattileResolveRec()
    rec: ref.wattileResolveRec(checked)
    
    // Return ref
    if (rec.isNull) do
      return null
    else do
      return rec.toRecId
    end
  end
---
name:wattileSyncHis
doc:
  Syncs Wattile prediction history for 'points' and 'span', using the specified Wattile Python 'task'.
  
  - 'points' may be anything accepted by `toRecIdList`.
  - 'span' may be anything acceptable by `toSpan`, or Null to sync all history after each point's 'hisEnd'.
  
  Each point must define valid tags `wattileModelRef` and `wattileQuantile`. If run within a task, will report task progress.
  
  Sync
  ----
  
  The default sync behavior is:
  
  1. Execute a prediction call to each Wattile model for the specified 'span'.
  2. Extract the 'horizon = 0' prediction data for each point based on its 'wattileQuantile'.
  3. Drop any predictions with timestamps prior to each point's 'hisEnd'.
  4. Write new prediction history is written persistently to each point.
  
  This behavior can be modified via 'opts'; see below.
  
  Options
  -------
  
  Sync behavior can be modified by control options passed via 'opts':
  
  - 'delay': Number; delay from the present for syncing predictions (Default = '0s')
  - 'forecast': Boolean; also write forecast data (Default = 'false')
  - 'forecastOnly': Boolean; *only* write forecast data (Default = 'false')
  - 'hotPeriod': Number; optional hot period for syncing predictions (Default = None)
  - 'limit': Number; limits the length of time span to sync when 'span' is Null (Default = None)
  - 'overwrite': Boolean; allows existing history to be overwritten (ignores 'hisEnd') (Default = 'false')
  - 'progress': Boolean; report task progress via `taskProgress` (Default = 'true')
  
  Boolean options may be also be passed as [markers]`haystack::Marker`, with 'x' equivalent to 'x:true' and '-x' equivalent to 'x:false'. If 'forecastOnly = true', the 'forecast' option is ignored. To avoid warning spam in the logs, the 'overwrite' and 'hotPeriod' options also set the `hisWrite` 'noWarn' flag.
  
  Model-specific sync options may also be defined via the `wattileSyncOpts` tag on a `wattileModel` record. Model-specific sync options apply to all points associated with that model and override values provided in 'opts'.
  
  Forecasts
  ---------
  
  If either the 'forecast' or the 'forecastOnly' option is 'true', then forecasts (data for 'horizon > 0' in Wattile results) are also written to each point. Only the forecast from the most recent Wattile prediction in the results (most recent value of the 'timestamp' column) is written. Forecasts are always written transiently by setting the `hisWrite` 'forecast' flag.
  
  Calculated Span
  ---------------
  
  If 'span' is Null, then the time span to sync is calculated for each set of points grouped by 'wattileModelRef'. For each group:
  
  - Start of span: Equals the earliest 'hisEnd' among points in the group or the beginning of the hot period, whichever is earlier
  - End of span: Equals the output of `now` minus 'delay' or the start of span plus 'limit' (when specified), whichever is earlier
  
  Note that any points without existing history ('hisEnd' equal to Null) are ignored when using a calculated span. When this function is called from a task or job to keep predictions up-to-date, best practice is to also specify 'limit' to avoid extremely large sync batches.
  
  Sync Delay
  ----------
  
  The 'delay' option delays syncing of predictions in "real time" to ensure complete input data, specified as a duration measuring backwards in time from the present (as returned by `now`). The minimum recommended 'delay' is the amount of time needed for predictor data to stabilize, *e.g.* for predictor point histories to sync and be written to disk. This helps ensure that the predictions are computed from complete and valid data.
  
  If 'span' is specified (non-Null), the 'delay' option is ignored.
  
  Hot Period
  ----------
  
  The 'hotPeriod' option functions similarly to the hot period for rules: during the hot period the synced predictions are continuously refreshed. This is accomplished by clearing point history within the hot period immediately prior to writing the new predictions. Like 'delay', 'hotPeriod' is specified as a duration measuring backwards in time from the present.
  
  Setting 'hotPeriod' greater than 'limit' will prevent predictions from being fully synced through the present. If 'span' is specified (non-Null), the 'hotPeriod' option is ignored.
func
overridable
src:
  (points, task, span:null, opts:{}) => do
    // Default options
    opts = {delay:0s, progress:true}.merge(opts)
    
    // Option processing/normalization function
    normalizeOpts: (opts) => do
      // T/F options
      opts = opts.set("forecast",      opts.has("forecast")      and opts["forecast"]      != false)
      opts = opts.set("forecastOnly",  opts.has("forecastOnly")  and opts["forecastOnly"]  != false)
      opts = opts.set("overwrite",     opts.has("overwrite")     and opts["overwrite"]     != false)
      opts = opts.set("progress",      opts.has("progress")      and opts["progress"]      != false)
  
      // Report task progress only if inside a task
      opts = opts.set("progress", taskIsRunning() and opts->progress)
  
      // If span is unspecified, never overwrite
      if (span == null) opts = opts.set("overwrite", false)
  
      // Sync delay
      opts = opts.set("delay", opts->delay.to(1s))
      
      // What to write
      opts = opts.set("writeHistory", not opts->forecastOnly)
      opts = opts.set("writeForecast", opts->forecast or opts->forecastOnly)
      
      // Hot period
      if (opts.has("hotPeriod")) do
        opts = opts.set("hotPeriod", opts->hotPeriod.to(1s))
      end
  
      // Span limit
      if (opts.has("limit")) do
        opts = opts.set("limit", opts->limit.to(1s))
      end
  
      // Warn if hot period > limit
      if (opts.has("hotPeriod") and opts.has("limit") and opts->hotPeriod > opts->limit) do
        logWarn(
          {name:"nrelWattile", funcTrace:"wattileSyncHis"},
          "Option 'hotPeriod' = " + format(opts->hotPeriod) +
          " is greater than option 'limit' = " + format(opts->limit) +
          "; synced predictions will lag real time."
        )
      end
      
      // Return normalized options
      return opts
    end
  
    // Error flag
    ok: true
  
    // Points
    points = points.toRecIdList.readByIds
  
    // Validate points
    points.each() p => do
      // Required tags
      if (p.missing("wattileModelRef")) throw "Point \"" + p.wattileRecDisWithId + "\" is missing 'wattileModelRef' tag"
      if (p.missing("wattileQuantile")) throw "Point \"" + p.wattileRecDisWithId + "\" is missing 'wattileQuantile' tag"
      if (p.missing("his")) throw "Point \"" + p.wattileRecDisWithId + "\" is missing 'his' tag"
      if (p.missing("tz")) throw "Point \"" + p.wattileRecDisWithId + "\" is missing 'tz' tag"
    end
  
    // Models
    models: points.map(p => p->wattileModelRef.toRec)
    if (models.isEmpty) do
      throw "No Wattile model records found!"
    else do
      models = models.unique("id")
    end
  
    // Span
    if (span != null) span = span.toSpan
  
    // Iterate models
    modifiedPoints: models.toRecList.flatMap() (model, i) => do
      // Get model-specific options
      modelOpts: opts
      if (model.has("wattileSyncOpts")) do
        modelOpts = modelOpts.merge(model->wattileSyncOpts)
      end
      
      // Process and normalize options
      modelOpts = normalizeOpts(modelOpts)
      
      // Get associated points
      pointsLocal: points.findAll(p => p->wattileModelRef == model->id)
  
      // Prediction span
      if (span == null) do
        // Only keep points with 'hisEnd'
        pointsLocal = pointsLocal.findAll(p => p.has("hisEnd"))
  
        // Ensure not empty
        if (pointsLocal.isEmpty) do
          logWarn(
            {name:"nrelWattile", funcTrace:"wattileSyncHis"},
            "No points with 'hisEnd' tag found for model " + model.wattileRecDisWithId + "; skipping."
          )
          return []
        end
  
        // Start: oldest 'hisEnd' or hot period start, whichever is older
        spanLocalStart: pointsLocal.toGrid.colToList("hisEnd").sort.first
        if (modelOpts.has("hotPeriod") and spanLocalStart >= (now() - modelOpts->hotPeriod)) do
          spanLocalStart = (now() - modelOpts->hotPeriod)
        end
  
        // End: the present, minus the sync delay (if any)
        spanLocalEnd: now().toTimeZone(spanLocalStart.tz) - modelOpts->delay
  
        // Span limit
        if (modelOpts.has("limit") and spanLocalEnd > (spanLocalStart + modelOpts->limit)) do
          spanLocalEnd = (spanLocalStart + modelOpts->limit)
        else if (spanLocalStart > spanLocalEnd) do
          return [] // Skip if up-to-date
        end
  
        // Return span
        spanLocal: spanLocalStart..spanLocalEnd
  
      else do
        // User-specified span
        spanLocal: span
      end
  
      // Task progress
      if (modelOpts->progress) do
        taskProgress({model:model.dis, span:spanLocal.format})
      end
  
      // Call predict
      try do
        data: task.taskSend({action: "predict", model:model, span:spanLocal}).futureGet()
      catch (ex) do
        logErr(
          {name:"nrelWattileExt", funcTrace:"wattileSyncHis"},
          "Prediction failed for model " + model.wattileRecDisWithId + ".",
          ex
        )
        ok = false
        return []
      end
  
      // Write prediction history
      if (modelOpts->writeHistory) do
        pointsLocal.each() p => do
          // Filter predictions
          history: data
            .findAll(row => row->horizon == 0 and row->quantile == p->wattileQuantile)
            .keepCols(["pred_ts", "pred_val"])
            .reorderCols(["pred_ts", "pred_val"])
            .renameCol("pred_ts", "ts")
  
          // Convert timezone
          history = history.map(row => row.set("ts", row->ts.toTimeZone(p->tz)))
  
          // Convert units
          history = history.hisMap(v => if (v.isNA) v else v.to(p["unit"]))
  
          // Write data
          if (modelOpts->overwrite) do
            // All history
            hisWrite(history, p, {noWarn})
          else if (p.missing("hisEnd")) do
            // All history
            hisWrite(history, p)
          else if (modelOpts.has("hotPeriod")) do
            // New history, using hot period
            hotPeriodStart: now() - modelOpts->hotPeriod
  
            // Remove existing point history in hot period; filter by hot period
            if (p->hisEnd >= hotPeriodStart) do
              p.hisRemove(hotPeriodStart..now())
              history = history.hisFindAll((val, ts) => ts >= hotPeriodStart)
  
            // No existing history in hot period; use hisEnd
            else do
              history = history.hisFindAll((val, ts) => ts > p->hisEnd)
            end
  
            // Write
            history.hisWrite(p, {noWarn})
          else do
            // New history only
            history
              .hisFindAll((val, ts) => ts > p->hisEnd)
              .hisWrite(p)
          end
        end
      end
  
      // Write prediction forecast
      if (modelOpts->writeForecast) do
        pointsLocal.each() p => do
          // Most recent prediction timestamp
          mostRecentTime: data.colToList("timestamp").sortr.first
  
          // Filter predictions
          history: data
            .findAll(row => row->timestamp == mostRecentTime and row->horizon > 0 and row->quantile == p->wattileQuantile)
            .keepCols(["pred_ts", "pred_val"])
            .reorderCols(["pred_ts", "pred_val"])
            .renameCol("pred_ts", "ts")
  
          // Convert timezone
          history = history.map(row => row.set("ts", row->ts.toTimeZone(p->tz)))
  
          // Convert units
          history = history.hisMap(v => if (v.isNA) v else v.to(p["unit"]))
  
          // Write data
          hisWrite(history, p, {forecast})
        end
      end
  
      // Return modified points
      pointsLocal.toRecList
    end
  
    // Check for error
    if (not ok) do
      throw "Error(s) occurred during Wattile prediction; see log."
    end
  
    // History sync then return modified point records
    hisSync()
    modifiedPoints.flatten.toRecIdList.readByIds
  end
---
name:wattileViewPredictionFit
doc:
  Visualize the goodness of fit of a Wattile 'model' during 'span'. The target is resolved via the model's `wattileTargetRef` or can be specified by the user via 'target'.
  
  The output of this function is a grid intended for viewing as a scatterplot:
  
  - Each plot point '(q, r)' represents one quantile predicted by the Wattile model
  - The X-axis value 'q' is the expected (predicted) quantile
  - The Y-axis value 'r' is the actual (observed) quantile
  
  The result is similar to the [quantile-quantile plot]`https://en.wikipedia.org/wiki/Q%E2%80%93Q_plot` (QQ plot) used to compare probability distributions.
  
  Details
  -------
  
  To generate the plot, the function:
  
  1. Reads the target's history and the model prediction history for 'span'
  2. Interpolates the history grid
  3. For each predicted quantile, calculate the fraction of target history values that are less than or equal to the prediction history values; this is the observed quantile
  4. Record the observed ('q') vs. predicted ('r') quantile as an output point on the plot.
  
  Only the quantiles associated with the available prediction points (via the `wattileQuantile` tag) are included in the analysis.
  
  Interpretation
  --------------
  
  For each plot point '(q, r)':
  
  - If 'r = q', the model accurately predicted the target values for quantile 'q' within 'span'
  - If 'r > q', the model overpredicted the target values for quantile 'q' within 'span'
  - If 'r < q', the model underpredicted the target values for quantile 'q' within 'span'
  
  Ideally, all points on the plot should lie on a 45° diagonal line (slope 1, intercept 0). This line is plotted in red for reference.
func
overridable
src:
  (model, span, target:null) => do
    // Plot parameters
    pointColor: "#34495e"
    parityLineWidth: 0.5
    parityLineColor: "red"
  
    // Get model
    model = model.toRec
  
    // Get time span
    span = span.toSpan
    
    // Get target point
    targetPoint: if (target != null) do
      target.toRec
    else if (model.has("wattileTargetRef")) do
      wattileResolveRec(model->wattileTargetRef)
    else do
      throw "Target was not specified and model does not have 'wattileTargetRef' tag."
    end
  
    // Get prediction points
    predictionPoints: xq()
      .xqReadAll(point and wattilePoint and prediction and wattileQuantile and wattileModelRef==model.toRecId)
      .xqExecute
      .sort("wattileQuantile")
    
    // Read target history
    targetHis: xq().xqReadByIds(targetPoint.toRecIdList).xqHisRead(span, {-limit}).xqExecute()
    
    // Calculate observed vs. predicted quantiles from target vs. prediction history   
    observations: predictionPoints.toRecList.map() p => do
      // Read prediction history
      predictionHis: xq().xqReadByIds(p.toRecIdList).xqHisRead(span, {-limit}).xqExecute()
      
      // Combine and interpolate
      hisGrid: hisJoin([
          targetHis.renameCol("v0", "target"),
          predictionHis.renameCol("v0", "prediction")
        ])
        .hisInterpolate
        .hisClip
        .findAll(row => row.hasAll(["target", "prediction"]))
      
      // Total values
      n: hisGrid.size
      
      // Number of values less than or equal to predicted quantile
      m: hisGrid.findAll(row => row->target <= row->prediction).size
      
      // Return X-value = predicted quantile, Y-value = observed quantile
      {q:p->wattileQuantile, r:(m/n)}
    end
    
    // Quantiles
    quantiles: predictionPoints.colToList("wattileQuantile")
    
    // Output grid
    observations
      .toGrid
      .addRows([{q:0, ref:0}, {q:1, ref:1}])
      .addRows(quantiles.map() q => {q:q, ref:q})
      .sort("q")
      .addMeta({view:"chart", title:"Wattile: Observed vs. Predicted Quantiles", subtitle:model.dis + " | " + format(span)})
      .addColMeta("q", {dis:"Predicted Quantile", chartMin:0, chartMax:1})
      .addColMeta("r", {dis:"Observed Quantile", chartType:"scatter", color:pointColor, chartGroup:"A", chartMin:0, chartMax:1})
      .addColMeta("ref", {dis:"Ideal Relationship", chartType:"line", color:parityLineColor, strokeWidth:parityLineWidth, chartGroup:"A"})
  end
---
name:wattileViewPredictionHistory
doc:
  Visualize Wattile 'model' prediction history for 'span'. If available, history from the model's target point is also shown. The target point is resolved via the model's `wattileTargetRef` or can be specified by the user via 'target'.
  
  Options
  -------
  
  Appearance can be modified by control options passed via 'opts':
  
  - 'interval': Time interval for `hisRollupAuto()` (Default = none)
  - 'lineColor': Target history line color (Default = "#34495e")
  - 'lineWidth': Target history line (stroke) width (Default = 1.5)
  - 'predictionGradient': List of colors used to create the prediction shading (Default = OrRd from [Color Brewer]`https://colorbrewer2.org/`)
  - 'predictionWidth': Prediction history line (stroke) width (Default = 0.5)
  
  The first color in 'predictionGradient' corresponds to the 0th percentile prediction and the last color corresponds to the 50th percentile (median) prediction. The gradient is interpolated in reverse for the 50th to 100th percentile.
func
overridable
src:
  (model, span, target:null, opts:{}) => do
    // Default options
    opts = {
      lineColor: "#34495e",
      lineWidth: 1.5,
      predictionGradient: ["#fef0d9", "#fdcc8a", "#fc8d59", "#e34a33", "#b30000"],
      predictionWidth: 0.5,
    }.merge(opts)
    
    // Default gradiant is 5-class OrRd from Color Brewer, https://colorbrewer2.org/
    
    // Get model
    model = model.toRec
    
    // Get time span
    span = span.toSpan
    
    // Check interval option
    if (opts.has("interval") and not opts->interval.isNumber) do
      throw "Invalid 'interval' option; must be a number."
    end
    
    // Get target point
    targetPoint: if (target != null) do
      target.toRec
    else if (model.has("wattileTargetRef")) do
      wattileResolveRec(model->wattileTargetRef)
    else do
      null
    end
    
    // Get prediction points
    predictionPoints: xq()
      .xqReadAll(point and wattilePoint and prediction and wattileModelRef==model.toRecId)
      .xqExecute
      .sort("wattileQuantile")
    
    // Read history
    targetHis: xq().xqReadByIds(targetPoint.toRecIdList).xqHisRead(span, {-limit}).xqExecute()
    predictionHis: xq().xqReadByIds(predictionPoints.toRecIdList).xqHisRead(span, {-limit}).xqExecute()
    
    // Target chart properties
    targetHis = targetHis.addColMeta("v0", {color:opts->lineColor, strokeWidth:opts->lineWidth})
    
    // Prediction chart color range
    predictionColors: opts->predictionGradient
    
    // Prediction chart properties
    predictionHis.cols.each() col => do
      // Column meta
      colMeta: col.meta
      
      // Skip ts
      if (col.name == "ts") return null
      
      // Quantile of this prediction
      q: colMeta->wattileQuantile
      
      // Select color
      if (q == 0.5) do
        color: predictionColors.last
      else if (q < 0.5) do
        color: vizInterpolateRgb(predictionColors, 2*q)
      else if (q > 0.5) do
        color: vizInterpolateRgb(predictionColors, 2*(1 - q))
      end
      
      // Custom opacity in area charts is currently unsupported; see: https://skyfoundry.com/forum/topic/5164.
      
      // Set chart area mode
      if (q == 0.5) do
        chartAreaMode: null
      else if (q < 0.5) do
        chartAreaMode: "nextSeries"
      else if (q > 0.5) do
        chartAreaMode: "prevSeries"
      end
      
      // Merge chart properties
      colMeta = colMeta.merge({
        color: color,
        strokeWidth: opts->predictionWidth,
        chartAreaMode: chartAreaMode
      })
      
      // Set col meta
      predictionHis = predictionHis.setColMeta(col.name, colMeta)
    end
    
    // Combine and return
    hisJoin([predictionHis, targetHis])
      .addMeta({
        title: "Wattile: Prediction History",
        subtitle: model.dis + " | " + format(span),
        chartLegendNoSort
      })
      .hisRollupAuto(opts["interval"])
  end
