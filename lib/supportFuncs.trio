name:wattileImportModels
doc:
  Imports Wattile models located in **dirs** and returns a list of `wattileModel` records ready to commit. **dirs** may be a single uri, a list of uris, or a grid with a 'uri' column.
  
  Each record includes tags:
  
  - 'wattileModel'
  - 'wattileTarget': Ref to model's target point, based on 'data_config.json'
  - 'uri': Path to the model directory
  
  The **checked** flag governs error handling:
  
  - If a directory does not exist or is not a valid Wattile model, throw an error if **checked** is 'true'; otherwise skip the directory
  - If the model target point cannot be found in the local project or anywhere in the cluster (via Xquery), throw an error **checked** is 'true'; otherwise set 'wattileTarget' to null
  
  Regardless of **checked**, if the Wattile model's configuration does not specify a target, 'wattileTarget' is set to null.
func
src:
  (dirs, checked:true) => do
    // If directories is a file grid, get URI column
    if (dirs.isGrid) dirs = dirs.colToList("uri")
    
    // Map dirs to wattileModel records
    models: dirs.toList.map() dir => do
      // Check directory uri
      if (not dir.isUri) dir = dir.parseUri(checked)
      
      // Check that the directory exists
      try do
        if (dir.isNull) throw "Model directory is null"
        if (ioDir(dir).isEmpty) throw "Model directory `" + dir.toStr + "` is empty or does not exist"
      catch (ex) do
        if (checked) throw (ex)
        return null // Invalid model
      end
      
      // Read data_config.json
      try do
        // Verify data_config.json exists
        if (ioDir(dir).find(f => f->name=="data_config.json") == null) do
          throw "Missing 'data_config.json'"
        end
        
        // Read
        dataConfig: ioReadJson(dir + "data_config.json", {v3}) // TO DO: Update to v4 encoding
      catch (ex) do
        if (checked) throw (ex)
        return null // Invalid model
      end
      
      // Model dict
      model: {wattileModel, uri:dir}
      
      // Get model target
      try do
        // Get target record ID
        if (dataConfig.has("target")) do
          target: dataConfig->target.toRecId
        else do
          target: null
        end
        
        // Verify target exists somewhere
        if (target != null) do
          // Try local first
          targetSearch: readById(target, false)
          
          // Try XQuery next
          if (targetSearch == null) do
            targetSearch: xq().xqReadByIdsList(target.toList).xqExecute
            
            // Point not found
            if (targetSearch.isEmpty) do
              throw "Target point " + target.toStr + " cannot be found."
            end
          end
          
          // If we made it here, search was successful
          
          // Extract fully referenced target
          if (targetSearch.isList) targetSearch = targetSearch.first
          target = targetSearch.toRecId
        end
        
        // Assign to model
        model = model.set("wattileTarget", target)
        
      catch (ex) do
        if (checked) throw (ex)
      end
      
      // TO DO: Also import model name?
      
      // Return model dict
      model
    end
    
    // Return models, minus anything skipped
    return models.findAll(m => m != null)
  end
---
name:wattileReadHis
doc:
  Predictive analytics helper function; reads history for **recs** and converts into a history grid compatible with a prediction call to Python via 'wattilePythonTask()'
  
  **TO DO:** Refine documentation. Should this be 'nodoc'?
func
src:
  // Helper function to read history and prepare it for conversion to Python dataframe
  (recs, span) => do
    // Convert to record list
    recs = recs.toRecList
  
    // Read histories and define column names (via 'dis' tags)
    data: recs.map() p => do
      // Get column 'dis'
      // This defines CSV export column names, but doesn't affect Python data frame column names
      if (p.has("dis")) do
        // Explicit pre-defined 'dis' (if available)
        dis: p["dis"]
  
      else do
        // Extract 'dis' from point metadata in database
        dis: p.toRecId.readById.dis
      end
  
      // Read history
      history: p.toRecId.hisRead(span) // toRecId() here prevents some hisRead() misfires
  
      // Check for empty history
      if (history.isEmpty) throw "No history found for input \"" + dis + "\" and timespan " + format(span)
  
      // Fix column 'dis' tag, and return
      history.addColMeta("v0", {dis:dis, -disMacro})
    end
  
    // Combine data, clip to window, and return
    hisJoin(data).hisClip
  end
---
name:wattileSyncPredictions
doc:
  Using the specified Wattile Python **task**, sync prediction data for all points associated with Wattile **model** for timestamp **ts**. Each 'wattilePoint' associated with **model** (via `wattileModelRef`) receives new history per its 'wattileHis' tag.
  
  Options
  -------
  
  By default, new prediction history is written persistently and any predictions with timestamps prior to each point's 'hisEnd' are dropped. This behavior can be modified by the following options, passed via **opts**:
  
  - 'overwrite': Marker; if present then existing history may be overwritten (ignores 'hisEnd')
  - 'forecastSplit': Number; if present splits the predictions as follows:
    - Writes predictions with timestamps up to and including **ts** + 'forecastSplit' persistently
    - Writes predictions with timestamps after **ts** + 'forecastSplit' transiently (sets `hisWrite` 'forecast' flag)
  - 'forecastOnly': Marker; writes all predictions transiently (sets `hisWrite` 'forecast' flag)
  
  
  To avoid warning spam in the logs, the 'overwrite' option also sets the `hisWrite` 'noWarn' flag. 'forecast' and 'forecastSplit' are mutually exclusive.
func
src:
  (task, model, ts, opts:{}) => do
    // Check options
    if (opts.has("forecastOnly") and opts.has("forecastSplit")) do
      throw "The 'forecastOnly' and 'forecastSplit' options are mutually exclusive"
    end
    
    // Model record
    model = model.toRec
    
    // Read points
    points: readAll(wattilePoint and wattileModelRef==model->id).toRecList
    
    // Model setup
    task.taskSend({
      action: "setup",
      model:  model
    })
    
    // Run prediction
    future: task.taskSend({
      action: "predict",
      ts:     ts
    })
  
    // Retrieve prediction data
    data: future.futureGet()
    
    // Filter function for new history
    newHistoryOnly: (v, t, h) => do
      if (h.has("hisEnd")) t > h->hisEnd else true
    end
    
    // Write to points
    points.each() p => do
      // Filter predictions
      preds: data
        .keepCols(["ts",p->wattileHis])
        .reorderCols(["ts",p->wattileHis])
        .sort("ts")
        
      // Overwrite or drop old history?
      if (opts.has("overwrite")) do
        hisWriteOpts: {noWarn}
      else do
        hisWriteOpts: {}
        preds = preds.hisFindAll(newHistoryOnly(_,_,p))
      end
        
      // Split past vs. future (forecast) predictions
      if (opts.has("forecastOnly")) do
        pastPreds: []
        forePreds: preds
      else if (opts.has("forecastSplit")) do
        splitTs: ts + opts->forecastSplit
        pastPreds: preds.hisFindAll((v, t) => t <= splitTs)
        forePreds: preds.hisFindAll((v, t) => t > splitTs)
      else do
        pastPreds: preds
        forePreds: []
      end
      
      // Write history
      if (not pastPreds.isEmpty) hisWrite(pastPreds, p, hisWriteOpts)
      if (not forePreds.isEmpty) hisWrite(forePreds, p, {forecast})
    end
     
    // History sync then return updated point records
    hisSync()
    points.toRecIdList.readByIds
  end
