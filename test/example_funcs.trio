name:testEnvironmentSetup
doc:
  Setup script to import test environment database records, functions, and point history into the current SkySpark project. Expects to find the following files in 'io' (required):
  
  - 'example_funcs.trio'
  - 'folio_records.trio'
  - 'folio_his.zinc'
  
  Optionally (with 'developer' option specified), also imports functions from:
  
  - 'pythonFuncs.trio'
  - 'supportFuncs.trio'
  - 'taskFuncs.trio'
  
  These files are available in the [intelligentcampus-model-deploy]`https://github.com/NREL/intelligentcampus-model-deploy` repo:
  
  - 'test/' directory for the required files
  - 'lib/' directory for the developer function files
  
  The single **opts** argument accepts the following control options:
  
  - 'resetProject': Marker; reset the project before import
  - 'developer': Marker; also imports functions for extension development
    (see above)
  
  Test Environment
  ----------------
  
  When executed, this function creates a test environment consisting of:
  
  1. A 'weatherStation' record with 7 weather points
  2. A 'site' record, with one 'meter' 'equip' record containing:
    a. One 'power' 'sensor' 'point' records
    b. Two 'power' 'prediction' 'point' records
  3. One 'task' record for interfacing with the Wattile Python package
  4. Two Wattile test models loaded as directories under 'io/wattile/': one each for the Alfa and Bravo Wattile architecture versions
  5. A variety of 'test*' functions that test various aspects of Wattile interaction; see below.
  
  The various 'sensor' point records are populated with a single month of synthetic history (December 2020).
  
  Test Functions
  --------------
  
  Test functions should be executed in the following order:
  
  1. 'testModelImport()': Import Wattile models as 'wattileModel' proxy records
  2. 'testModelSetup()': Prepare Wattile models on disk for prediction
  3. 'testPrediction()': Execute predictions using Wattile models
  4. 'testPredictionPointSetup()': Prepares 'prediction' points to receive predictions
  5. 'testPredictionPointSync()': Sync predictions from Wattile models to 'prediction' points in SkySpark
  
  Some 'test*' functions accept an 'opts' argument that adjusts the behavior; see individual function documentation for details.
  
  Project Reset
  -------------
  
  In general, to start clean you need to reset the project. If the 'resetProject' option is present (set), then this setup function will:
  
  1. Trash all existing 'weatherStation', 'site', 'equip', 'point', 'task', and 'wattileModel' records from the current project
  2. Empty the trash
  3. Remove all existing model directories in 'io/wattile/models/'
  4. Overwrite any existing 'example*' or 'test*' functions found in 'example_funcs.trio'
  5. Overwrite any existing extension functions (if 'developer' option is set)
  
  **Warning:** there is no recovery of any existing records or files after using the 'resetProject' option. Use with care!
func
src:
  (opts:{}) => do
    // Default options
    opts = {}.merge(opts)
  
    // Clear existing records (if applicable)
    if (opts.has("resetProject")) do
      // Existing recs
      recsToTrash: readAll(weatherStation or site or equip or point or wattileModel or task)
      if (not recsToTrash.isEmpty) do
        // Trash recs
        recsToTrash.recTrash
  
        // Empty trash
        folioEmptyTrash()
        
        // Remove `io/wattile/` directory
        ioDelete(`io/wattile/`)
      end
    end
    
    // Import Folio records
    recs: ioReadTrio(`io/folio_records.trio`)
      .toRecList
      .map(rec => diff(null, rec, {add}))
      .commit
  
    // Helper function: create new or overwrite existing example functions
    funcDiff: (rec) => do
      existing: read(func and name==rec->name, false)
      if (existing != null and opts.has("resetProject")) do
        return diff(existing, rec)
      else do
        return diff(null, rec, {add})
      end
    end
  
    // Import example functions (required)
    ioReadTrio(`io/example_funcs.trio`)
      .toRecList
      .map(funcDiff)
      .commit
  
    // Import developer functions (optional)
    if (opts.has("developer")) do
      // File list
      files: ioDir(`io/`)
  
      // Find available developer functions
      files = files
        .findAll() f => f->name.in(["pythonFuncs.trio", "supportFuncs.trio", "taskFuncs.trio"])
  
      // Commit each
      files.each() f => ioReadTrio(f->uri).toRecList.map(funcDiff).commit
    end
  
    // Read point history
    data: ioReadZinc(`io/folio_his.zinc`)
  
    // Data columns (minus timestamp)
    columns: data.colNames.remove(0) // 'ts' is column 0
  
    // Write point history by point
    columns.each() cn => do
      // Point to write
      point: readById(data.col(cn).meta->id)
  
      // Data to write
      pointData: data
        .keepCols(["ts", cn])
        .hisFindAll((v, t) => v != null)
  
      // Write history
      hisWrite(pointData, point)
    end
  
    // User-specified image
    if (opts.has("image")) do
      image: opts->image
      task: read(task and dis=="Wattile Python Task")
      diff(
        task,
        {taskExpr:task->taskExpr.replace("\"wattile\"", "\"" + opts->image + "\"")}
      ).commit
  
    // Default image
    else do
      image: "wattile"
    end
    
    // Load 
    
    // Copy the test model into io/wattile/models/
    // Note: First removes any existing test_model directory!
    py({image:image})
      .pyExec("import shutil")
      .pyExec("shutil.copytree('/trained_models/alfa_exp_dir/', '/io/wattile/alfa_model/')")
      .pyExec("shutil.copytree('/trained_models/bravo_exp_dir/', '/io/wattile/bravo_model/')")
      .pyEval("'Done!'")
  end
---
name:testModelImport
func
src:
  () => do
    // Import Wattile models
    wattileModels: ioDir(`io/wattile/`).wattileImportModels({conflict:"error"})
    
    // Import Wattile model, Alfa variant
    alfaModel: wattileModels.find() f => f->uri.toStr.lower.contains("alfa")
    alfaModel = diff(null, alfaModel.merge({dis:"Wattile Example: Alfa"}), {add}).commit
    
    // Import Wattile model, Bravo variant
    bravoModel: wattileModels.find() f => f->uri.toStr.lower.contains("bravo")
    bravoModel = diff(null, bravoModel.merge({dis:"Wattile Example: Bravo"}), {add}).commit
    
    // Return imported models
    [alfaModel, bravoModel]
  end
---
name:testModelSetup
func
src:
  () => do
    // Wattile Python task
    wattileTask: read(wattileTask)
    
    // Run model setup for all wattileModel records
    readAll(wattileModel).each() model => do
      // Run model setup
      wattileTask.taskSend({action:"setup", model:model}).futureGet
      
      // Verify setup
      config: ioReadJson(model->uri + "configs.json")
      if (config->learning_algorithm->use_case != "prediction") do
        throw "Model setup failed for: " + model.dis
      end
    end
    
    // Return
    "ok"
  end
---
name:testPrediction
func
src:
  (opts:{}) => do
    // Default options
    opts = {
      model: read(wattileModel and dis=="Wattile Example: Alfa"), // Wattile model
      span:  dateTime(2021-12-08, time(08,00), "Denver")          // Time range for prediction
    }.merge(opts)
    
    // Wattile Python task
    wattileTask: read(wattileTask)
  
    // Run prediction
    wattileTask
      .taskSend({action: "predict", model:opts->model, span:opts->span})
      .futureGet()
  end
---
name:testPredictionPointSetup
func
src:
  () => do
    // Get prediction points
    points: readAll(point and wattilePoint and wattileQuantile and predictionOf==@p:wattile_test:r:294fd256-a17bb5c7)
    
    // Abort if existing model refs
    n: points.findAll(p => p.has("wattileModelRef")).size
    if (n > 0) do
      throw n.toStr + " points already have 'wattileModelRef'"
    end
    
    // Models
    alfaModel: readAll(wattileModel).find(m => m->uri.toStr.contains("alfa") and m.dis.lower.contains("alfa"))
    bravoModel: readAll(wattileModel).find(m => m->uri.toStr.contains("bravo") and m.dis.lower.contains("bravo"))
    
    // Assign models to points: bounds from Alfa, median from Bravo
    diffs: points.toRecList.map() p => do
      if (p->wattileQuantile == 0.25) return diff(p, {wattileModelRef:alfaModel.toRecId})  // Lower bound
      if (p->wattileQuantile == 0.50) return diff(p, {wattileModelRef:bravoModel.toRecId}) // Median
      if (p->wattileQuantile == 0.75) return diff(p, {wattileModelRef:alfaModel.toRecId})  // Upper bound
    end
    
    // Commit
    diffs.commit
  end
---
name:testPredictionPointSync
func
src:
  (opts:{}) => do
    // Default options
    defaultSpan: dateTime(2021-12-08, time(00,00), "Denver")..dateTime(2021-12-08, time(08,00), "Denver")
    opts = {
      span:      defaultSpan, // Time range for prediction
      overwrite: true,        // Overwrite?
      forecast:  false,       // Sync forecast?
    }.merge(opts)
      
    // Wattile Python task
    wattileTask: read(wattileTask)
    
    // Points: all properly-configured Wattile points
    points: readAll(point and wattilePoint and wattileQuantile and wattileModelRef)
    
    // Call sync
    syncOpts: {overwrite:opts["overwrite"], forecast:opts["forecast"]}
    points.wattileSyncHis(wattileTask, opts->span, syncOpts)
  end
